=-*- mode: org; mode: visual-line;  -*-=
#+STARTUP: indent

* =twizzle= [[http://travis-ci.org/cassiel/nanomator][https://secure.travis-ci.org/cassiel/twizzle.png]] [[https://www.versioneye.com/user/projects/53d2a43b851c56dc68000231][https://www.versioneye.com/user/projects/53d2a43b851c56dc68000231/badge.svg]]

* Introduction

A Clojure library for simple timeline-based automation, useful for animation systems.

An automation state maps named /channels/ to time-varying values. Each channel can be populated with automation segments, each of which has a start time, duration and target value for the channel's value.

=nanomator= doesn't have a particular notion of time: it just uses integer counters which can be milliseconds (for realtime animation), frames (for rendering), or anything else.

By default, channel values are floats (mainly because the default interpolator returns floats), but it's possible to attach interpolation functions to allow automation over arbitrary data values (for example, vectors of floats for RGB colour mixing).

* Usage

** Setup

In =project.clj=:

#+BEGIN_SRC clojure
  [eu.cassiel/nanomator "0.1.0-SNAPSHOT"]
#+END_SRC

In the code:

#+BEGIN_SRC clojure
  (:require [eu.cassiel [nanomator :as nn]])
#+END_SRC

Create a new automation state with

#+BEGIN_SRC clojure
  (def state (nn/initial))
#+END_SRC

For a state with non-default starting values, add an initialisation map:

#+BEGIN_SRC clojure
  (def state (nn/initial :init {:pitchbend 64
                                :starts-at-one 1.0}))
#+END_SRC

Note that default initial value is =nil=. The default interpolator will interpret a start point of =nil= as =0= in any calculations, so once you start fading you'll get floats, but before any fades take effect the sampled value will come back as =nil=.

** Sampling and Fading

Add an automation fade to a state:

#+BEGIN_SRC clojure
(nn/automate state :my-param 200 10 1.0)
#+END_SRC

Arguments are: state, channel name, starting timestamp, duration, final (target) value. This returns a new state. The fade duration (which here has length =10=) specifies that the fade terminates at =210=; sampling here will return =1.0=. Sampling at =209= will return a value slightly biased towards the previous value of =:my-param=.

Sampling anywhere beyond this fade will return the final value of the fade (=1.0=). If several consecutive fades are present for a channel, the result will be the final value of the fade with the highest starting time. (Aside: don't overlap fades on the same channel.)

Locate a state to a particular position:

#+BEGIN_SRC clojure
  (nn/locate state 300)
#+END_SRC

A call to =locate= returns a new state with any fades which lie in front of the specified timestamp (here, =300=) to be removed, once they've been sampled: in other words, the fades are /chased/, so that the target values of purged fades are applied. Example:

#+BEGIN_SRC clojure
  (-> (nn/initial)
      (nn/automate :my-param 100 10 9.9)
      (nn/locate 150)
      (nn/sample :my-param))
#+END_SRC

This last example returns =9.9=, the target of the purged fade. If we added a second locate point at =50= on the line after the first locate (say: in front of the original fade), the result would still be =9.9=, since the first =locate= would have chased that fade and removed it.

Sample a state at its current timestamp:

#+BEGIN_SRC clojure
  (nn/sample state :pitchbend)
#+END_SRC

A call to =sample= just returns the sampled value at that timestamp; the state is not changed.

** Interpolating

For automation over values more interesting than floats, provide an interpolation function:

#+BEGIN_SRC clojure
  (def state (nn/initial :interp {:foreground colour-mix
                                  :background colour-mix}
                         :init {:foreground [1 1 1]
                                :background [0 0 0]}))
#+END_SRC

The interpolator (in this case, =colour-mix=) will be called with three arguments: start value, end value, and interpolation position (from =0.0= to =1.0=). Unless =nil= works as a potential initial value, provide that as well.

* Documentation

The source documentation is [[https://cassiel.github.io/nanomator][here]].

* License

Copyright Â© 2014 Nick Rothwell.

Distributed under the Eclipse Public License either version 1.0 or (at your option) any later version.
