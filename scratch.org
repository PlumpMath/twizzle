-*- mode: org; mode: visual-line; -*-
#+STARTUP: indent

* SCRATCH

** Random testing

#+BEGIN_SRC clojure
  (defn foo [& {:keys [init] :or {init {}}}]
    {:got-it init})

  (foo :init {:A 24})
  (foo)

  (map (fn [[a b]] (+ a b))
       (zipmap [1 2 3] [4 5 6]))


  (->> (interleave [1 2 3] [4 5 6])
       (partition 2)
       (map (fn [[x y]] (+ x y))))


  (reduce-kv (fn [m k v] (assoc m k (- v))) nil {:A 1 :B 3})
#+END_SRC

** Internal testing

#+BEGIN_SRC clojure
  (ns user
    (:require [eu.cassiel [twizzle :as tw]]))

  (tw/apply-to-fades {:sequences {:A {:fades (seq [1 4 66 78])}
                                  :B {:fades (seq [999]) :current 3.142}
                                  :C {:fades nil}}}
                     #(conj % 0))

  (tw/apply-to-sequences {:sequences {:A {:fades (seq [1 4 66 78])}
                                      :B {:fades (seq [999]) :current 3.142}
                                      :C {:fades nil}}}
                         (fn [x] (-> x
                                    (update-in [:fades] #(conj % 0))
                                    (update-in [:current] (constantly 0.5)))))

  (tw/automate (tw/initial) :A 100 10 1.0)

  (-> (tw/initial :init {:X 99})
      (tw/automate :X 100 20 0)
      (tw/locate 100)
      (tw/sample :X))

  (-> (tw/initial)
      (tw/locate 105)
      (tw/automate :my-param 100 10 10.0)
      (tw/sample :my-param))

  (tw/purge-and-sample {:fades (seq [{:start 100 :dur 10 :target 10.0}])}
                       105)
#+END_SRC
